## ДЗ 3.3 Операционные системы Ворсин Денис


1. Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd.
   
chdir("/tmp"")

![chdir](https://i.ibb.co/R0SHJGZ/2021-11-17-11-45-27.jpg)

2. Попробуйте использовать команду file на объекты разных типов на файловой системе. 
Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.

/usr/share/misc/magic.mgc

![files](https://i.ibb.co/GnLY5XY/2021-11-19-13-37-51.jpg)

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

![make file](https://i.ibb.co/xftVT0d/2021-11-19-13-47-48.jpg)
![delete file](https://i.ibb.co/ChBQgr8/2021-11-19-13-52-21.jpg)
    
4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

Зомби не занимают ресурсы (такие как CPU, RAM), но занимают ID процесса, 
и если их будет слишком много новые процессы не смогут запуститься.    

5. В iovisor BCC есть утилита opensnoop:

    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.

![opensnoop](https://i.ibb.co/P970kJM/2021-11-19-14-14-15.jpg)
    
6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
 
вызов uname

![uname](https://i.ibb.co/FXZz8WK/2021-11-19-14-23-07.jpg)

ниже выдержка из `man 2 uname`: 


         Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.


Версия ядра и релиз ОС:

![osrelease](https://i.ibb.co/1sYFxXR/2021-11-19-14-26-46.jpg)

![kernel version](https://i.ibb.co/7brjd77/2021-11-19-14-26-54.jpg)


7. Чем отличается последовательность команд через ; и через && в bash? 


            Команды, запущенные через ; будут выполнены независимо от кода завершения предыдущей команды. 
            Команды, запущенные через && будут выполнены если предыдущая команда вернула код завершения 0.
    
Есть ли смысл использовать в bash &&, если применить set -e?


        set -e завершает баш если любая команда вернула ненулевой код завершения. 
        использовать bash && нет большого смысла, т.к. в любом случае след команда не будет выполнена.

9. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
   - e Exit immediately if a command exits with a non-zero status (немедленный выход если команда вернула ошибку)
   - u Treat unset variables as an error when substituting (неопределённые переменные воспринимают как ошибки)
   - x Print commands and their arguments as they are executed (вывод команды с аргументами при исполнении)
   - o the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status (код возврата пайпа соответствует коду последней команды с ненулевым кодом завершения или нулю если небыло команд с ненулевым кодом завершения)        


        хорошо бы использовать в сценария, т.к. вывод будет более детализированный и завершится на моменте возникновения ошибки, может быть проще отладка.


10. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).


![ps man](https://i.ibb.co/7WpgL19/2021-11-19-15-21-32.jpg)


![stats](https://i.ibb.co/k6jNYdS/2021-11-19-15-41-21.jpg)

Спящих процессов больше всего.