## ДЗ 3.2 Работа в терминале, Ворсин Денис.
 
####1. Какого типа команда cd? 

вывод комманды `type` показывает, что `cd` - встроенная команда `bash`

![cd builtin](https://i.ibb.co/khrY0j1/2021-11-15-23-14-16.jpg)

####2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? man grep поможет в ответе на этот вопрос.
```shell
grep -c somestring somefile
```

####3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
systemd

![systemd](https://i.ibb.co/tLVfxfL/2021-11-15-15-54-08.jpg)

####4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
```sh
ls 2> /dev/pts/2
```

####5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

```sh 
while read ln; do echo "num $ln";done <somefile  > output_here
```

в данном примере файл somefile передается в stdin а вывод сохраняется в output_here


####6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

работая в терминале перенаправим вывод в /dev/tty3
 
![graph term](https://i.ibb.co/HpK1QfJ/2021-11-15-13-47-14.jpg)

для того чтобы посмотреть, что появилось в терминале tty3 можно в него переключиться через ctrl+alt+F3

![tty3 term](https://i.ibb.co/1nLC3Hs/2021-11-15-13-46-34.jpg)

####7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
   

          запустит еще один баш и в нем создаст дескриптор 5, который перенаправляет вывод в stdout
![bash to 5](https://i.ibb.co/bWCRphr/2021-11-15-15-52-02.jpg)

####8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

![pipe redirect](https://i.ibb.co/6PhF4rv/2021-11-15-15-33-50.jpg)
В данном примере grep красным показывает, что в него данные поступили через pipe, если же в полученной строке не обнаружено совпадений, то строка будет отфильтрована. 
т.е. сообщение `error` прошло через `pipe` а сообщение `output` не прошло через `pipe`, но было отображено.

####9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

          
          Команда выдает переменные окружения, с которыми работает процесс $$
          Альтернативный вариант - Выполнить команду `env`


####10. Используя man, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
man procfs:
     - `/proc/<PID>/cmdline` - текстовый файл в режиме только-чтение, содержит полную командную строку процесса, если только процесс не зомби.
     - `/proc/<PID>/exe` - начиная с линукс 2.2 это символьная ссылка содержащая полный путь до исполняемого файла.

![man procfs1](https://i.ibb.co/dGgMvpj/2021-11-15-23-45-54.jpg)
![man procfs2](https://i.ibb.co/XDLQQXg/2021-11-15-23-46-16.jpg)
    
####11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
```shell
grep -Eo "sse[0-9_]+" /proc/cpuinfo
```
![grep cpuinfo](https://i.ibb.co/WtsTBhT/2021-11-15-23-19-16.jpg)

####12. При открытии нового окна терминала через vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
 ```
    vagrant@netology1:~$ ssh localhost 'tty'
    not a tty
```
так происходит, потому что `ssh` используется только для выполнения команды `tty`, в этом случае ssh pty не подключает.
Чтобы изменить поведение надо:  
```shell
ssh -t localhost 'tty'
```
В этом случае `ssh` при подключении подключит терминал.

![ssh term](https://i.ibb.co/pQtBmQZ/2021-11-15-23-56-38.jpg)

####13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. 

на примере `vim` запущенного в терминале:

изначально имеем `vim` с номером процесса 1246 в терминале `pts/0`

![1](https://i.ibb.co/QPTyB1T/2021-11-15-19-07-44.jpg)

далее, нам понадобилось перенести `vim` в `screen`, после чего все сессии кроме `screen` были закрыты. 

![2](https://i.ibb.co/XJWpwK8/2021-11-15-19-19-03.jpg)

здесь уже `vim` в терминале pts/3 но номер процесса тот же - 1246

####14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, 
так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. 
Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. 
    
    
`tee` принимает stdin и пишет в stdout и в файл

![tee](https://i.ibb.co/JR5sq4L/2021-11-16-00-10-26.jpg)

когда мы делаем `sudo echo`, то с правами рута исполняется только `echo`, а перенаправление уже занимается `bash` с нашими текущими правами.
Когда мы используем `sudo tee`, то здесь к файлу обращается не `bash` а `tee`, запущенный с правами рута. 

Еще один пример на ту же тему:

![sh](https://i.ibb.co/JzFNjW3/2021-11-16-00-13-16.jpg)

